<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Джигсо пъзел - Mihaela</title>
    <!-- Open Graph мета тагове за по-добро споделяне във Facebook -->
    <meta property="og:title" content="Джигсо пъзел - Mihaela">
    <meta property="og:description" content="Забавлявай се с този джигсо пъзел! Подреди парчетата, за да разкриеш снимката на Mihaela. Избери ниво на трудност и се наслади на играта!">
    <meta property="og:image" content="https://deyan80.github.io/puzzle-ivanovi/djani_daid.jpg">
    <meta property="og:image:width" content="600">
    <meta property="og:image:height" content="400">
    <meta property="og:url" content="https://deyan80.github.io/puzzle-ivanovi/">
    <meta property="og:type" content="website">
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background-color: #f0f0f0; }
        #controls { margin: 20px; }
        #board { border: 2px solid #333; background-color: white; display: block; margin: 20px auto; touch-action: none; }
        #info { margin: 10px; font-size: 18px; }
        button { padding: 10px 15px; margin: 5px; font-size: 16px; }
        #source { display: none; }
        canvas.dragging { cursor: grabbing; }
    </style>
</head>
<body>
    <h1>Джигсо пъзел - Mihaela</h1>
    
    <div id="controls">
        <label>Трудност:</label><br>
        <button onclick="init(3)">3 x 3 (лесно)</button>
        <button onclick="init(4)">4 x 4 (средно)</button>
        <button onclick="init(6)">6 x 6 (трудно)</button>
        <br><br>
        <button onclick="shuffle()">Разбъркай</button>
        <button onclick="showSolution()">Покажи</button>
        <button id="playPauseBtn" onclick="togglePlay()">Пусни музика</button>
    </div>
    
    <canvas id="board" width="600" height="400"></canvas>
    
    <div id="info">
        <span>Време: <span id="time">00:00</span></span> |
        <span>Ходове: <span id="moves">0</span></span>
    </div>
    
    <p>Влачете цветните парчета върху празното място, за да ги преместите.</p>
    
    <img id="source" src="djani_daid.jpg" alt="Снимка на Mihaela">
    <audio id="backgroundMusic" src="song.mp3" loop></audio>
    
    <script>
        let canvas = document.getElementById('board');
        let ctx = canvas.getContext('2d');
        let img = document.getElementById('source');
        let size = 3;
        let tileSize;
        let board = [];
        let blankPos = {x: 0, y: 0};
        let moves = 0;
        let timer;
        let timeElapsed = 0;
        let isSolved = false;
        let isLoaded = false;
        let draggedTile = null;
        let dragOffset = {x: 0, y: 0};
        let lastTouchPos = null;
        let audio = document.getElementById('backgroundMusic');
        let playPauseBtn = document.getElementById('playPauseBtn');

        img.onload = function() {
            console.log('Image loaded successfully');
            isLoaded = true;
            init(size);
        };

        img.onerror = function() {
            console.error('Failed to load image.');
            alert('Грешка при зареждане на изображението.');
        };

        audio.onerror = function() {
            console.error('Failed to load audio.');
            alert('Грешка при зареждане на музиката.');
        };

        function togglePlay() {
            if (audio.paused) {
                audio.play().then(() => {
                    playPauseBtn.innerText = 'Спри музика';
                }).catch(error => {
                    console.error('Audio play failed:', error);
                    alert('Грешка при пускане на музиката.');
                });
            } else {
                audio.pause();
                playPauseBtn.innerText = 'Пусни музика';
            }
        }

        function init(newSize) {
            if (!isLoaded) {
                alert('Изображението все още не е заредено.');
                return;
            }
            size = newSize;
            tileSize = Math.min(canvas.width / size, canvas.height / size);
            canvas.width = tileSize * size;
            canvas.height = tileSize * size;
            board = Array.from({length: size * size}, (_, i) => i);
            board[size * size - 1] = -1;
            blankPos = {x: size - 1, y: size - 1};
            moves = 0;
            timeElapsed = 0;
            isSolved = false;
            document.getElementById('moves').innerText = moves;
            document.getElementById('time').innerText = '00:00';
            if (timer) clearInterval(timer);
            timer = setInterval(updateTime, 1000);
            draw();
            canvas.removeEventListener('mousedown', startDragging);
            canvas.removeEventListener('mousemove', drag);
            canvas.removeEventListener('mouseup', drop);
            canvas.removeEventListener('mouseleave', cancelDrag);
            canvas.removeEventListener('touchstart', startTouch);
            canvas.removeEventListener('touchmove', touchMove);
            canvas.removeEventListener('touchend', touchEnd);
            canvas.addEventListener('mousedown', startDragging);
            canvas.addEventListener('mousemove', drag);
            canvas.addEventListener('mouseup', drop);
            canvas.addEventListener('mouseleave', cancelDrag);
            canvas.addEventListener('touchstart', startTouch, { passive: false });
            canvas.addEventListener('touchmove', touchMove, { passive: false });
            canvas.addEventListener('touchend', touchEnd, { passive: false });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#ccc';
            for (let i = 0; i <= size; i++) {
                ctx.beginPath();
                ctx.moveTo(i * tileSize, 0);
                ctx.lineTo(i * tileSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * tileSize);
                ctx.lineTo(canvas.width, i * tileSize);
                ctx.stroke();
            }
            for (let i = 0; i < board.length; i++) {
                let row = Math.floor(i / size);
                let col = i % size;
                let x = col * tileSize;
                let y = row * tileSize;
                let tileNum = board[i];
                if (tileNum !== -1 && i !== draggedTile) {
                    let srcRow = Math.floor(tileNum / size);
                    let srcCol = tileNum % size;
                    let srcX = srcCol * tileSize + (img.width - canvas.width) / 2;
                    let srcY = srcRow * tileSize + (img.height - canvas.height) / 2;
                    ctx.drawImage(img, srcX, srcY, tileSize, tileSize, x, y, tileSize, tileSize);
                } else if (tileNum === -1) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(x, y, tileSize, tileSize);
                    ctx.strokeStyle = '#333';
                    ctx.strokeRect(x, y, tileSize, tileSize);
                }
            }
            if (draggedTile !== null && lastTouchPos) {
                let tileNum = board[draggedTile];
                let srcRow = Math.floor(tileNum / size);
                let srcCol = tileNum % size;
                let srcX = srcCol * tileSize + (img.width - canvas.width) / 2;
                let srcY = srcRow * tileSize + (img.height - canvas.height) / 2;
                ctx.globalAlpha = 0.8;
                ctx.drawImage(img, srcX, srcY, tileSize, tileSize, 
                    lastTouchPos.x + dragOffset.x, lastTouchPos.y + dragOffset.y, tileSize, tileSize);
                ctx.globalAlpha = 1.0;
            }
        }

        function getTileAt(x, y) {
            let col = Math.floor(x / tileSize);
            let row = Math.floor(y / tileSize);
            if (col >= 0 && col < size && row >= 0 && row < size) {
                return row * size + col;
            }
            return -1;
        }

        function startDragging(event) {
            if (isSolved || !isLoaded) return;
            let rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;
            let index = getTileAt(x, y);
            if (index >= 0 && board[index] !== -1) {
                draggedTile = index;
                dragOffset.x = (index % size) * tileSize - x;
                dragOffset.y = Math.floor(index / size) * tileSize - y;
                lastTouchPos = {x: x, y: y};
                canvas.classList.add('dragging');
                draw();
            }
        }

        function startTouch(event) {
            if (isSolved || !isLoaded) return;
            event.preventDefault();
            if (event.touches.length > 1) return;
            let rect = canvas.getBoundingClientRect();
            let x = event.touches[0].clientX - rect.left;
            let y = event.touches[0].clientY - rect.top;
            let index = getTileAt(x, y);
            if (index >= 0 && board[index] !== -1) {
                draggedTile = index;
                dragOffset.x = (index % size) * tileSize - x;
                dragOffset.y = Math.floor(index / size) * tileSize - y;
                lastTouchPos = {x: x, y: y};
                canvas.classList.add('dragging');
                draw();
            }
        }

        function drag(event) {
            if (draggedTile === null) return;
            let rect = canvas.getBoundingClientRect();
            lastTouchPos = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
            draw();
        }

        function touchMove(event) {
            if (draggedTile === null) return;
            event.preventDefault();
            if (event.touches.length > 1) return;
            let rect = canvas.getBoundingClientRect();
            lastTouchPos = {
                x: event.touches[0].clientX - rect.left,
                y: event.touches[0].clientY - rect.top
            };
            draw();
        }

        function drop(event) {
            if (draggedTile === null || isSolved || !isLoaded) return;
            let rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;
            let targetIndex = getTileAt(x, y);
            let blankIndex = blankPos.y * size + blankPos.x;
            if (targetIndex === blankIndex) {
                [board[draggedTile], board[blankIndex]] = [board[blankIndex], board[draggedTile]];
                blankPos.x = Math.floor(draggedTile % size);
                blankPos.y = Math.floor(draggedTile / size);
                moves++;
                document.getElementById('moves').innerText = moves;
                draw();
                checkSolved();
            }
            draggedTile = null;
            lastTouchPos = null;
            canvas.classList.remove('dragging');
            draw();
        }

        function touchEnd(event) {
            if (draggedTile === null || isSolved || !isLoaded) return;
            event.preventDefault();
            let rect = canvas.getBoundingClientRect();
            let x = lastTouchPos ? lastTouchPos.x : event.changedTouches[0].clientX - rect.left;
            let y = lastTouchPos ? lastTouchPos.y : event.changedTouches[0].clientY - rect.top;
            let targetIndex = getTileAt(x, y);
            let blankIndex = blankPos.y * size + blankPos.x;
            if (targetIndex === blankIndex) {
                [board[draggedTile], board[blankIndex]] = [board[blankIndex], board[draggedTile]];
                blankPos.x = Math.floor(draggedTile % size);
                blankPos.y = Math.floor(draggedTile / size);
                moves++;
                document.getElementById('moves').innerText = moves;
                draw();
                checkSolved();
            }
            draggedTile = null;
            lastTouchPos = null;
            canvas.classList.remove('dragging');
            draw();
        }

        function cancelDrag() {
            draggedTile = null;
            lastTouchPos = null;
            canvas.classList.remove('dragging');
            draw();
        }

        function checkSolved() {
            let solved = board.every((value, index) => value === index || (index === board.length - 1 && value === -1));
            if (solved) {
                isSolved = true;
                clearInterval(timer);
                draw();
                alert('Поздравления! Решихте пъзела!');
            }
        }

        function shuffle() {
            if (isSolved || !isLoaded) return;
            for (let i = 0; i < 1000; i++) {
                let directions = [
                    {dx: 0, dy: -1}, {dx: 0, dy: 1},
                    {dx: -1, dy: 0}, {dx: 1, dy: 0}
                ];
                let dir = directions[Math.floor(Math.random() * 4)];
                let newX = blankPos.x + dir.dx;
                let newY = blankPos.y + dir.dy;
                if (newX >= 0 && newX < size && newY >= 0 && newY < size) {
                    let newIndex = newY * size + newX;
                    let blankIndex = blankPos.y * size + blankPos.x;
                    [board[newIndex], board[blankIndex]] = [board[blankIndex], board[newIndex]];
                    blankPos.x = newX;
                    blankPos.y = newY;
                }
            }
            moves = 0;
            timeElapsed = 0;
            document.getElementById('moves').innerText = moves;
            document.getElementById('time').innerText = '00:00';
            draw();
        }

        function showSolution() {
            board = Array.from({length: size * size}, (_, i) => i);
            board[size * size - 1] = -1;
            blankPos = {x: size - 1, y: size - 1};
            isSolved = true;
            moves = 0;
            document.getElementById('moves').innerText = moves;
            clearInterval(timer);
            draw();
        }

        function updateTime() {
            timeElapsed++;
            let minutes = Math.floor(timeElapsed / 60);
            let seconds = timeElapsed % 60;
            document.getElementById('time').innerText = 
                (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
        }

        window.onload = function() {
            if (isLoaded) init(3);
        };
    </script>
</body>
</html>